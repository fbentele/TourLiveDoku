\chapter{Android Aufnahmesystem}

Folgendes Kapitel behandelt das auf Google Android basierende Aufnahmesystem. Das Aufnahmesystem besteht aus zwei separaten Android Applikationen mit der Bezeichnung \textit{TourLive.apk} sowie \textit{TourLiveRecoveryService.apk}. Der Fokus folgender Unterkapitel liegt auf den Spezifikationen und der technischen Umsetzung des Aufnahmesystems und ist für Entwickler gedacht, die das Aufnahmesystem gerne erweitern möchten.

\section{Software Analyse}
Dieses Kapitel beschreibt die Anforderungen ans Aufnahmesystem und gibt einen groben Übersicht über die vorhandene Funktionalität.

\subsection{Anforderungen an das Aufnahmesystem}

Um die Anforderungen zu evaluieren wurde das bestehende Aufnahmesystem auf Basis von Nokia Symbian analysiert. Alle vorhandenen Funktionen wurden erfasst und gemeinsam mit dem Industriepartner um weitere ergänzt. 
Eine kurze Übersicht über die bereits bestehenden Funktionen und den neu erfassten Anforderungen liegt in tabellarischer Form vor.

\begin{longtable}{  p{3.5cm} | p{4.3cm} | p{4.3cm} }
    
    \textbf{Requirements} & \textbf{Altes System} & \textbf{Neues System} \\ [1ex] \hline \hline & &  \\ [-1.5ex]
    Positionsdaten übertragen & Geschwindigkeit, H\"{o}he, Richtung/Beschleunigung, Steigung, Longitude, Latitude & Geschwindigkeit, H\"{o}he, Richtung, Steigung, Longitude, Latitude \\ [1ex] \hline & &  \\ [-1.5ex]
    Etappendaten & Zeit, Höhe, Distanz, Durchschnittliche Geschwindigkeit, UTC Zeit, Datum & Zeit, Höhe, Distanz, Durchschnittliche Geschwindigkeit \\ [1ex] \hline & &  \\ [-1.5ex]
     Tour Total & Zeit Total, Zeit Tour, Distanz Total, Distanz Tour, Höhe Total, H\"{o}he Tour & - \\ [1ex] \hline & &  \\ [-1.5ex]
    Netzdaten übertragen & Zellen ID, Location Area, Signal, Akku, Netzwerk, Netzwerk ID & Zellen ID, Area, Signal, Netzwerk ID, Technologie, Datenrate, RTT, Packet Loss\\ [1ex] \hline & &  \\ [-1.5ex]
    Bilder \"{u}bertragen & wird unterstützt & wird unterstützt \\ [1ex] \hline & &  \\ [-1.5ex]
    Videostream \"{u}bertragen & Einzelne Bilder wurden \"{u}bertragen und serverseitig zu einem Stream zusammengef\"{u}gt & Videosequenzen werden \"{u}bertragen und serverseitig zu einem Stream zusammengesetzt\\ [1ex] \hline & &  \\ [-1.5ex]
    Lokales Caching & nur Bilder wurden gecacht & S\"{a}mtliche aufgenommene Daten werden lokal gespeichert\\ [1ex] \hline & &  \\ [-1.5ex]
	Aufnahme- systemstatus \"{u}bertragen & nur der Akkustand wurde an das Device Management Portal \"{u}bertragen & Detaillierte Statusinformation an das Device Management Portal\\ [1ex] \hline & &  \\ [-1.5ex]   
    Betriebsmodi & - & Managed - Einstellungen \"{u}ber das Portal / Unmanaged - Einstellungen am Ger\"{a}t\\ [1ex] \hline & &  \\ [-1.5ex]
	Auto-Start der App & - & App wird beim Ger\"{a}testart automatisch gestartet\\ [1ex] \hline & &  \\ [-1.5ex]
    Externe Ger\"{a}te & ODB (Onboard Diagnose Bus) und Pulsinfo Ger\"{a}te wurden angesteuert & -\\ [1ex] \hline & &  \\ [-1.5ex]
    Smartphone tauglich & Symbian App & Android App\\ [1ex] \hline & &  \\ [-1.5ex]
    Log & Position und Bilder gesendet & Daten, Bilder, Status und Einstellungen gesendet / Exceptions\\ [1ex] \hline & &  \\ [-1.5ex]
    Aufnahmestart Modi & Aufnahme hat automatisch bei App Start gestartet & Manuell, Zeitbasiert, Fernverwaltet oder bei Aktivierung einer externen Stromquelle\\ [1ex] \hline & &  \\ [-1.5ex]
   	Power Management & - & Bei niedrigem Akkustand wird ein Energiesparmodus aktiviert\\ [1ex] \hline & &  \\ [-1.5ex]
    Alarming Funktion & - & Treten Probleme auf, so wird darauf hingewiesen (z.B. keine GPS Daten w\"{a}hrend 2 Minuten)\\ [1ex] \hline & &  \\ [-1.5ex]
    Mehrsprachig- keit & - & Deutsch und Englisch, einfach erweiterbar\\ [1ex] \hline & &  \\ 
    [-1.5ex] Fehlerkorrektur der GPS Daten & - & Ausreisser bei den GPS Daten werden herausgefiltert\\ [1ex] \hline & &  \\ 
    [-1.5ex] Notfallwiederherstel- lung per SMS & wird unterstützt & wird unterstützt\\ [1ex]
    
\caption{Anforderungen Android Aufnahmesystem}
\end{longtable}

Eine detaillierte Beschreibung aller Anforderungen befindet sich im Anhang im Kapitel \ref{sec:anforderungenandroiddevmgmt}.

\subsection{Verwendete Technologien}

\subsubsection{Android}
Eine Voraussetzung für das Aufnahmesystem ist, dass dieses in Form einer Android Applikation entwickelt wird. Die native Programmiersprache für Android Applikationen ist Android Java, ein der Java Standard Edition sehr ähnliches Java Derivat. Die Programmierung in Java bringt den Vorteil, dass die gesamte Android-\gls{api} benutzt werden kann. Da sämtliche Komponenten des TourLive Projektes in Java geschrieben sind kann teilweise auf Server- wie auch Clientseite auf dieselben Klassen-Bibliotheken zurückgegriffen werden, was mögliche Inkompatibilitäten vermindert. 

\paragraph{Android Version}
Eine Anwendung wird f"{u}r eine konkrete Android Version (Minimum Required SDK) entwickelt. Im Rahmen dieses Projektes wird als minimale SDK Version Android 4.0 (Versionsname: Ice Cream Sandwich\footnote{Android Ice Cream Sandwich, \url{http://www.android.com/about/ice-cream-sandwich/}, aufgerufen am 29.04.2013}, , API-Level: 14) verwendet. Die Applikation sollte gemäss Android Richtlinien kompatibel mit allen darauffolgenden Android Versionen sein.

\subsubsection{Externe Libraries}
Um den geforderten Funktionsumfang umzusetzen, wird auf folgende zwei externe Bibliotheken zurückgegriffen.

\paragraph{Spring for Android\footnote{Spring for Android, \url{http://www.springsource.org/spring-android}, aufgerufen am 29.04.2013} }
Ein Rest Client für Android von den Entwicklern des Java Spring Frameworks. Der Rest Client bietet die einfache Möglichker von Serialisierung / Deserialisierung von Java Objekten in JSON-Strings. 

Verwendete Version: spring-android-1.0.1

\paragraph{ORMLite\footnote{ORMLite, \url{ormlite.com}, aufgerufen am 02.05.2013}} ORMLite ist eine OpenSource Java Library, welche das Object-Relational Mapping (ORM) übernimmt. ORMLite bietet eine speziell auf Android angepasste Distribution an. Um Objekte und ihre Attribute zu persistieren, werden diese in den Modelklassen mit Java Annotationen markiert. ORMLite wird verwendet um die gesammelten Informationen lokal in einer Datenbank zu speichern und damit Datenverlust bei Verbindungsunterbrüchen verhindern zu können.

Verwendete Version: ORMLite-4.45

\subsection{Paper Protoypes}
Nach dem die Anforderungen definiert waren, haben wir Paper Prototypes erstellt. Diese wurden mit dem Industriepartner besprochen. So konnten mögliche Missverständnise eliminiert werden. Hier eine Übersicht über alle erstellten Mockups. Eine genauere Beschreibung befindet sich im Anhang im Kapitel \ref{sec:externesdesignandroid}.

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{images/android/OverviewAndroid.png}
	\caption{Übersicht Android Mockups}
\end{figure}

\subsection{Domain Model}


\section{Software Design}
\subsection{Architektur und Übersicht}
Die Android Applikation sammelt Daten für die beiden Server. In der Abbildung \ref{fig:grobstrukturandroid}
 wird veranschaulicht, welche Daten an welchen Server verschickt werden.

\begin{figure}[H]
	\centering
	\includegraphics[width=120mm]{images/android/uebersicht.png}
	\caption{Grobstruktur der Android App}
	\label{fig:grobstrukturandroid} 
\end{figure}


\subsubsection{Architekturentscheide}

\paragraph{Caching}
Um sämtliche aufgenommene Daten zu Cachen, haben wir uns für die Objektrelationale Abbildung der Klassen in der SQLite Datenbank entschieden. Dies ermöglicht mit Annotation eine schnelle Einbindung. Alternativen wären die Speicherung in ein Textfile oder die Speicherung in der Datenbank ohne Objektrelationale Abbildung, jedoch stand beides nicht zur Diskussion, da sie einem ORM gegenüber viele Nachteile bringen.

\paragraph{Datenhaltung}
Um die verschiedenen Services und Container überall zur Verfügung zu haben und somit lange Aufrufketten zu verhindern, wurde ein Singleton Repository eingeführt. In diesem Repository können über Methoden auf alle Daten zugegriffen werden, die von diversen Klassen gebraucht werden.

\paragraph{TourLiveApplication}
Beim Start der Applikation müssen viele Daten initialisiert werden. Um dies bereits zu machen, bevor eine View geladen wurde, wurde eine TourLiveApplication erstellt, welche von der Android Klasse Application abgeleitet wird. 

\subsection{Schichtenmodell und Paketdiagramm}
Die Android Applikation teilt sich in 3 Schichten auf.

\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{images/android/schichten.jpg}
	\caption{Packagediagramm des Aufnahmesystems}
\end{figure}

Die oberste Schicht stellt die Schnittstelle zum Benutzer dar. Diese Klassen sind für die Darstellung zuständig.\\
In der nächsten Schicht ist die ganz Businesslogik enthalten. Hier werden bei einer Aufnahme alle Timer gestartet und verwaltet und die jeweiligen Aktionen ausgeführt. \\
In der letzten Schicht enthält die Domäne des Aufnahmesystems.

\section{Realisierung}

\subsection{GUI}
Die \textit{MainActivity} ist die Hauptansicht der Applikation. Sie ist in drei Teile unterteilt, Header, Footer und Hauptbereich. Diese Klasse wird direkt nach der Erstellung der TourLiveApplication erstellt. Header und Footer sind in allen Tabs sichtbar.

\begin{figure}[H]
	\centering
	\includegraphics[width=120mm]{images/android/status.png}
	\caption{Aufnahmesystem MainActivity}
\end{figure}


\subsubsection{Header}
\begin{figure}[H]
	\centering
	\includegraphics[width=60mm]{images/android/header.png}
	\caption{Aufnahmesystem Header}
\end{figure}
Der Header beinhaltet in der Action Bar die aktuelle Versionsnummer sowie den Settings Button. Um auf einen Blick zu sehen, dass die App am aufnehmen ist, steht oben Rechts REC. \\
In der Top Bar werden die verschiedenen Tabs angezeigt. Mit einem Swipe nach rechts und links kann zwischen den Tabs hin und her gewechselt werden.

\paragraph{Settings Button}
Bei einem Klick in der Action Bar auf den Settings Button, erscheint das folgende Menu.

\begin{figure}[H]
	\centering
	\includegraphics[width=60mm]{images/android/settingsclicked.png}
	\caption{Aufnahmesystem Settings Button Clicked}
\end{figure}

Läuft die Aufnahme, so wird das Einstellungs Menu disabled. Die restlichen Aktionen sind trotzdem Verfügbar.


\subsubsection{Footer}
\begin{figure}[H]
	\centering
	\includegraphics[width=60mm]{images/android/footer.png}
	\caption{Aufnahmesystem Footer}
\end{figure}
Der Footer zeigt auf einen Blick den Status der App. Die Icons werden je nach Wert rot, gelb oder grün angezeigt. Welche Farben wann angezeigt werden, ist in den Reqirements im Anhang im Kapitel \ref{par:alarming} beschrieben.\\
Mit dem Recording Button links kann die Aufnahme gestartet und gestoppt werden. Dieser ist nur sichtbar, wenn der Aufnahmemodus auf Manuell gesetzt ist.


\subsubsection{Hauptbereich}
Der Inhalt des Hauptbereichs hängt vom selektierten Tab ab. Bei jedem Tab wird ein Fragment hinzugefügt. Dieses Fragment besitzt jeweils eine ListView, in der alle Felder angezeigt werden. 

\pagebreak
\subsection{Berechtigungen}
Beim installieren der App wird angezeigt, welche Berechtigungen benötigt werden. Hier wird aufgelistet, für was welche Berechtigungen gebraucht werden.
\begin{figure}[H]
	\centering
	\includegraphics[width=60mm]{images/android/berechtigungen.png}
	\caption{Aufnahmesystem Berechtigungen}
\end{figure}
\subsubsection{Datenschutz}
\textbf{Telefonstatus und Identität abrufen:} Mit dieser Berechtigung kann die Telefonnummer ausgelesen werden\\
\textbf{Bilder und Videos aufnehmen:} Um Bilder und Videos aufzunehmen wird diese Berechtigung gebraucht\\
\textbf{Audio aufnehmen:} Während dem Video aufnehmen wird auch Audio aufgenommen\\
\textbf{Genauer Standort:} Hiermit kann die aktuelle Position ausgelesen werde\\
\textbf{USB Speicherinhalte ändern und löschen:} Die Bilder und Videos sowie die exportierte Datenbank werden auf der externen Speicherkarte gespeichert \\

\subsubsection{Gerätezugriff}
\textbf{Netzwerkverbindungen anzeigen:} Dank dieser Berechtigung kann geprüft werden, ob die Verbindung gut ists \\
\textbf{Beim Start ausführen:} Beim Start des Telefons wird das Aufnahmesystem automatisch gestartet sofern diese Einstellung aktiviert ist \\
\textbf{Zugriff auf geschützten Speicher testen:} Seiteneffekt beim Zugriff auf den USB Speicher

\subsection{Services}
Um wiederkehrende Aktionen auszuführen wird ein Timer mit einem TimerTask benötigt. Der TimerTask implementiert das Interface Runnable. Bei Ablauf des Timers wird die Methode \textit{run} ausgeführt. 

\subsection{Kommunikation zum Server}
Die Kommunikation zu den Servern wird in den abgeleiteten Klassen des AsyncTasks ausgeführt. Der AsyncTask wurde verwendet da nach der Abfrage auf dem Server das GUI aktualisiert werden muss und dies nur aus dem GUI Thread erlaubt ist. \\
Der AsyncTask wird mittel \textit{execute} ausgeführt, dies führt die Methode \textit{doInBackground} aus. Diese wiederum ruft am Schluss \textit{onPostExecute} auf. Die \textit{onPostExecute} Methode läuft im Gegensatz zur Methode \textit{doInBackground} im GUI Thread, somit kann hier das GUI aktualisiert werden.
\\Für jede Kommunikation mit dem Server wurde eine eigene AsyncTask Klasse erstellt.

\subsection{Datenbank}
Für das lokale Caching werden Daten mittels ORMLite in die Datenbank geschrieben. Eine Klasse wird mittels Annotation als Datenbankklasse erkannt.

\begin{lstlisting}[language=Java, caption=ORMLite Annotations]
@DatabaseTable
public class Device {
	@JsonIgnore
	@DatabaseField(generatedId = true)
	private int id;
	@DatabaseField
	private String deviceId;
	@DatabaseField
	private String username;
	@DatabaseField
	private String phoneNr;
}
\end{lstlisting}

\textbf{\textit{@DatabaseTable}:} mit dieser Annotation wird angegeben, dass diese Klasse eine gemappte Datenbank Klasse ist.\\
\textbf{\textit{@DatabaseField}:} das folgende Attribut ist eine Spalte in der Datenbank. Mittels generatedID = true wird für das Attribut eine eindeutige ID generiert.\\

Die Klasse \textit{DatabaseHelper} führt den Zugriff auf die Datenbank aus. Beim ersten Start der App werden alle Tabellen generiert. Werden später neue Attribute hinzugefügt, so muss die Datenbankversion erhöht und in der \textit{onUpgrade} Methode ein UpdateScript zur Verfügung gestellt werden.\\

Der DatenbankManager, eine Singleton Klasse, ermöglicht den Zugriff über den \textit{DatabaseHelper} auf die Datenbank. Hier werden alle benötigten CRUD Methoden aufgerufen.

\subsection{Abläufe}

\subsubsection{Permanente Tasks}
In der folgenden Grafik sieht man alle Tasks, die ausgeführt werden, während die App läuft. 
\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{images/android/permanent_taskes.jpg}
	\caption{Aufnahmesystem Permanente Tasks}
\end{figure}
Alle paar Minuten wird ein StatusData an den Device Management Server versendet. Das Intervall kann nur im Code verändert werden. Als Antwort wird der aktuellste DeviceManagementContainer zurückgegeben und damit die lokalen Einstellungen gefüllt. Wurde in diesem DeviceManagementContainer das Flag \textit{messageAvailable} gesetzt, so wird die neue Nachricht vom Server geholt.\\
Ebenso wird in diesem Intervall geprüft, ob die StageInfo vorhanden ist, oder veraltet. Ist diese der Fall, so wird die StageInfo neu vom Server bezogen.

\pagebreak
\subsubsection{Recording}
Die folgende Abbildung zeigt den Ablauf, beim Starten der Aufnahme.
\begin{figure}[H]
	\centering
	\includegraphics[width=150mm]{images/android/recording.jpg}
	\caption{Aufnahmesystem Aufnahme}
\end{figure}

Beim Starten der Aufnahme werden alle Services gestartet. Beim ValueContainerService wird ein Listener für Positionsänderungen hinzugefügt, welcher in einem in den Einstellungen definierten Intervall die aktuelle Position mitteilt. Wird auf dem Listener \textit{onLocationChanged} aufgerufen, so wird ein neuer ValueContainer kreiiert und an den Server gesendet.\\
Zusätzlich zum ValueContainerService wird der ImageService oder VideoService gestartet. Welcher von beiden benutzt wird hängt von dem definierten MediaRecording Modus ab. Bei beiden wird ein Timer gestartet, welcher periodisch Fotos oder Videos aufnimmt und diese an den TourLive Server sendet.

\subsection{Algorithmen}
Das Aufnahmesystem enthält einige Algorithmen zur Berechnung von Distanzen, Steigungen und Zeit. Diese werden in folgendem Unterkapitel kurz beschrieben. Damit eine Berechnung durchgeführt werden kann wird ein \textit{StageInfo}-Objekt vorausgesetzt der beschreibt in welchem Rennen beziehungsweise in welcher Etappe sich das Aufnahmegerät aktuell befindet.
\\

\subsubsection{Berechnung der Renndauer}
Die Renndauer ist in der TourLive Applikation im Tab Etappe (eng. Stage) zu finden und beschreibt die Renndauer seit dem offiziellen Etappenstart gemäss \textit{StageInfo}. Die Berechnung der Renndauer erfolgt durch eine einfache Subtraktion.

\begin{center}
\textit{if StageInfo is available \\
 return now - StageInfo.StageStartTime \\
else return 0} 
\end{center}


Die Renndauer wird bei der Erstellung eines \textit{ValueContainers} im assoziierten \textit{StageData} im Attribut \textit{stageTime} gespeichert.

\subsubsection{Berechnung der überwundenen Höhenmeter}
Die überwundenen Höhenmeter repräsentieren das Total der positiv überwundenen Höhenmeter während einer Etappe. Der Wert wird in der TourLive Applikation im Tab Etappe (eng. Stage) angezeigt. Die Berechnung erfolgt nach folgendem Algorithmus.

\begin{center}
\textit{var Altitude = 0\\
getAllValueContainers since StageInfo.StageStartTime\\
if CurrentValueContainer.Altitude < NextValueContainer.Altitude\\
Altitude += NextValueContainer.Altitude - CurrentValueContainer.Altitude}
\end{center}

Die überwundenen Höhenmeter werden bei der Erstellung eines \textit{ValueContainers} im assoziierten \textit{StageData} im Attribut \textit{stageUpAltitude} gespeichert.
\subsubsection{Berechnung der Steigung}
Die Angabe zur Steigung beziehen sich auf die letzten 100m Horizontaldistanz. Die Steigung wird im Tab Etappe (eng. Stage) angezeigt und bei der Erstellung eines \textit{ValueContainers} im assoziierten \textit{StageData} als Attribut \textit{incline} gespeichert. Die Berechnung erfolgt nach folgendem Algorithmus.

\begin{center}
var Altitude = 0\\
var Distance = 0\\
lastValueContainer = null\\
List valueContainers getAllValueContainersAsReverseList()\\
while valueContainers.hastNext\\
if valueContainer is in currentStage\\
	Altitude += lastValueContainer.Altitude - valueContainer.Altitude\\
	Distane += lastValueContainer.Distance - valueContaienr.Distance\\
	lastValueContainer = ValueContainer\\

	if distance > 100\\
		break\\
else\\
	break\\

incline = altitude / distance\\
return arctan(incline.toDegrees)\\

\end{center}

\subsubsection{Allgemeine Algorithmen zur Vermeidung von Berechnungsfehlern}
Die Erstellung eines ValueContainers erfolgt sobald das Aufnahmegerät eine neue Position meldet. Es kann vorkommen, dass die GPS-API von Android fehlerhafte Positionsdaten sammelt. Aus diesem Grund werden erstellte ValueContainer auf ihre Datenkonsistenz überprüft und gegebenenfalls wieder verworfen. Der ValueContainer wird nach folgenden Kriterien überprüft:
\begin{itemize} [noitemsep,topsep=0pt]
	\item longitude != 0
	\item latitude != 0
	\item accuracy < 100m
	\item returned location from GPS\_PROVIDER != null
\end{itemize}
